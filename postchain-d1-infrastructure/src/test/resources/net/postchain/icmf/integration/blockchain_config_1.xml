<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!-- Copyright (c) 2020 ChromaWay AB. See README for license information. -->

<dict>
    <entry key="blockstrategy">
        <dict>
            <entry key="name">
                <!-- Needed for testing -->
                <string>net.postchain.devtools.OnDemandBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.d1.icmf.integration.IcmfTestBlockchainConfigurationFactory</string>
    </entry>
    <entry key="signers">
        <array>
            <!-- Key0 -->
            <bytea>03a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070</bytea>
            <!-- Key1 -->
            <bytea>031B84C5567B126440995D3ED5AABA0565D71E1834604819FF9C17F5E9D5DD078F</bytea>
            <!-- Key2 -->
            <bytea>03B2EF623E7EC933C478135D1763853CBB91FC31BA909AEC1411CA253FDCC1AC94</bytea>
        </array>
    </entry>
    <entry key="gtx">
        <!--
        If multiple GTX modules are used, allowoverrides will decide if query- and operation names of
        modules are overridable. If false (default) an error will be thrown on startup if two or more
        modules have name collisions. If true, The last module with a colliding name will take precedence
        (blockchain.1.gtx.allowoverrides=true).
        -->
        <dict>
            <entry key="modules">
                <array>
                    <string>net.postchain.d1.icmf.IcmfGTXModule</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="modules">
                        <array>
                            <string>icmf</string>
                        </array>
                    </entry>
                    <entry key="sources">
                        <dict>
                            <entry key="icmf/module.rell">
                            <string><![CDATA[module;

@log
entity sent_icmf_message {
    topic: text;
    block_height: integer;
    body: byte_array;
    index topic, block_height;
}

query icmf_get_all_messages(topic: text, height: integer): list<gtv> {
    return sent_icmf_message @* { topic, .block_height >= height } ( gtv.from_bytes(.body), @omit @sort .rowid );
}

query icmf_get_messages(topic: text, height: integer): list<gtv> {
    return sent_icmf_message @* { topic, .block_height == height } ( gtv.from_bytes(.body), @omit @sort .rowid );
}

function send_message(topic: text, body: gtv) {
    create sent_icmf_message(
        topic = topic,
        block_height = op_context.block_height,
        body = body.to_bytes()
    );

    val previous_message_block_height = sent_icmf_message @? { topic, .block_height < op_context.block_height } ( @max .block_height ) ?: -1;
    op_context.emit_event("icmf_message", (topic = topic, body = body, previous_message_block_height = previous_message_block_height).to_gtv_pretty());
}

operation test_message(text) {
    send_message("my-topic", text.to_gtv());
}
                            ]]></string>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="version">
                        <string>0.10.11</string>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
</dict>
