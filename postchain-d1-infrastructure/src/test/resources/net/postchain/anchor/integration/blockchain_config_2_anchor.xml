<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!-- Copyright (c) 2020 ChromaWay AB. See README for license information. -->

<!--  =================================================================================
This is a Anchor Chain configuration specifically for testing.

 1. On demand block building Strategy (enables us to tell the test when to build a new block)
 2. GTX BC config factory (must handle GTX TXs) // TODO: Olle don't know if really needed?
 3. Anchor module, which does everything we need around anchoring.
================================================================================= -->
<dict>
    <entry key="blockstrategy">
        <dict>
            <entry key="name">
                <!-- Needed for testing -->
                <string>net.postchain.devtools.OnDemandBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="configurationfactory">
        <!-- Must use GTX since we need it -->
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="icmflistener">
        <string>10</string> <!-- Anchor chain listens to messages from all chains with no number or lower number. This only works for managed mode, manual don't know about other chains. -->
    </entry>
    <entry key="signers">
        <array>
            <!-- Key0 -->
            <bytea>03a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070</bytea>
            <!-- Key1 -->
            <bytea>031B84C5567B126440995D3ED5AABA0565D71E1834604819FF9C17F5E9D5DD078F</bytea>
            <!-- Key2 -->
            <bytea>03B2EF623E7EC933C478135D1763853CBB91FC31BA909AEC1411CA253FDCC1AC94</bytea>
        </array>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="modules">
                <array>
                    <!-- Note: we don't want GTXTestModule here, b/c we are not supposed to write any "normal" TXs -->
                    <string>net.postchain.d1.anchor.AnchorGTXModule</string> <!-- This is the Anchor module: essential!  -->
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="modules">
                        <array>
                            <string>anchor</string>
                        </array>
                    </entry>
                    <entry key="sources">
                        <dict>
                            <entry key="anchor/module.rell">
                            <string><![CDATA[module;

entity anchor_block {
    blockchain_rid: byte_array;
    block_rid: byte_array;
    block_height: integer;
    status: integer;
}

struct block_header {
    blockchain_rid: byte_array;
    previous_block_rid: byte_array;
    merkle_root_hash: byte_array;
    timestamp: integer;
    height: integer;
    dependencies: gtv; // Can be either GtvNull or GtvArray
    extra: map<text,gtv>;
}

operation __anchor_block_header(block_rid: byte_array, header: block_header, witness: byte_array) {
    create anchor_block(blockchain_rid = header.blockchain_rid, block_rid = block_rid, block_height = header.height, status = 0);

    process_icmf(header);
}

query get_last_anchored_block(blockchain_rid: byte_array): struct<anchor_block>? {
    return anchor_block @? { blockchain_rid } (@omit @sort_desc .block_height, $.to_struct()) limit 1;
}

query get_anchored_block_at_height(blockchain_rid: byte_array, height: integer): struct<anchor_block>? {
    return anchor_block @? { blockchain_rid, .block_height == height } ($.to_struct());
}

entity icmf_message {
    key topic: text,
        sender: byte_array,
        sender_height: integer;
    hash: byte_array;
    anchor_height: integer;
    index topic, anchor_height;
}

struct icmf_packet {
    sender: byte_array;
    sender_height: integer;
    hash: byte_array;
}

function process_icmf(header: block_header) {
    val icmf_data = map<text,byte_array>.from_gtv(header.extra["icmf_send"]);
    for (topic in icmf_data.keys()) {
        create icmf_message(
            anchor_height = op_context.block_height,
            topic = topic,
            sender = header.blockchain_rid,
            sender_height = header.height,
            hash = icmf_data[topic]
        );
    }
}

query get_icmf_hash(topic: text, sender: byte_array, sender_height: integer): byte_array? {
    return icmf_message @? {topic, sender, sender_height} (.hash);
}

query get_icmf_messages_since_height(anchor_height: integer, topic: text): list<icmf_packet> {
    return icmf_message @* {.anchor_height >= anchor_height, topic} (icmf_packet(sender = .sender, sender_height = .sender_height, hash = .hash));
}
]]></string>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="version">
                        <string>0.10.11</string>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
</dict>