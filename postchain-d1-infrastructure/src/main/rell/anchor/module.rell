module;

entity anchor_blocks {
    blockchain_rid: byte_array;
    block_rid: byte_array;
    block_height: integer;
    status: integer;
}

struct block_header {
    blockchain_rid: byte_array;
    previous_block_rid: byte_array;
    merkle_root_hash: byte_array;
    timestamp: integer;
    height: integer;
    dependencies: gtv; // Can be either GtvNull or GtvArray
    extra: map<text,gtv>;
}

operation __anchor_block_header(block_rid: byte_array, header: block_header, witness: byte_array) {
    create anchor_blocks(blockchain_rid = header.blockchain_rid, block_rid = block_rid, block_height = header.height, status = 0);

    process_icmf(header);
}

struct anchor_block {
    block_rid: byte_array;
    block_height: integer;
    status: integer;
}

query get_last_anchored_block(blockchain_rid: byte_array): anchor_block? {
    val block = anchor_blocks @? { blockchain_rid } (block_rid = .block_rid, @sort_desc block_height = .block_height, status = .status) limit 1;
    return if (block == null) null else anchor_block(block_rid = block.block_rid, block_height = block.block_height, status = block.status);
}

query get_anchored_block_at_height(blockchain_rid: byte_array, height: integer): anchor_block? {
    return anchor_blocks @? { blockchain_rid, .block_height == height } (anchor_block(block_rid = .block_rid, block_height = .block_height, status = .status));
}
