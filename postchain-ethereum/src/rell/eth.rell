enum asset_type {
    erc20
}

entity eth_block {
    key eth_block_height: integer;
    key eth_block_hash: text;
}

entity eth_event {
    index eth_block;
    tnx_hash: text;
    log_index: integer;
    event_signature: text;
    contract_address: text;
    from_address: text;
    to_address: text;
    amount: integer;
}

entity eth_balance {
    token: text;
    beneficiary: text;
    key token, beneficiary;
    mutable amount: integer;
}

entity eth_withdraw {
    key serial: integer;
    token: text;
    beneficiary: text;
    amount: integer;
}

struct eth_event_data {
    serial: integer;
    token: byte_array;
    beneficiary: byte_array;
    amount: integer;
}

struct state_data {
    state_n: integer;
    account: eth_event_data;
}

query get_last_eth_block() { return eth_block @? {} (@sort_desc .eth_block_height, .eth_block_hash) limit 1;}

operation __eth_block(eth_block_height: integer, eth_block_hash: text) {

    var eth_block = eth_block @? { eth_block_height, eth_block_hash };

    if (empty(eth_block)) {
        create eth_block(
            eth_block_height,
            eth_block_hash
        );
    }
}

operation __eth_event(eth_block_height: integer, eth_block_hash: text, tnx_hash: text, log_index: integer,
                        event_signature: text, contract_address: text,
                        type: asset_type, payload: gtv) {

    var eth_block = eth_block @? { eth_block_height, eth_block_hash };

    if (empty(eth_block)) {
        eth_block = create eth_block(
            eth_block_height,
            eth_block_hash
        );
    }

    val argList = list<gtv>.from_gtv(payload);
    // If we don't know about this asset type we ignore it
    when (type) {
        erc20 -> erc20_deposit(
            eth_block, tnx_hash, log_index, event_signature, contract_address,
            to_zero_padded_hex(byte_array.from_gtv(argList[0])),
            to_zero_padded_hex(byte_array.from_gtv(argList[1])),
            integer.from_gtv(argList[2])
        );
    }
}

function erc20_deposit(block: eth_block, tnx_hash: text, log_index: integer,
                        event_signature: text, contract_address: text,
                        from_address: text, to_address: text, token_amount: integer) {
    val eth_event = create eth_event(
        block,
        tnx_hash,
        log_index,
        event_signature,
        contract_address,
        from_address,
        to_address,
        amount = token_amount
    );

    val balance = eth_balance @? { .token == to_address, .beneficiary == from_address };

    if (empty(balance)) {
        create eth_balance(
            token = to_address,
            beneficiary = from_address,
            amount = token_amount
        );
    }
    update balance (amount += token_amount);
}

function to_zero_padded_hex(array: byte_array) {
    return "0x" + array.to_hex();
}

operation withdraw(token: text, beneficiary: text, w_amount: integer) {
    val b = eth_balance @ { token, beneficiary };
    require(b.amount >= w_amount, "Balance is too low");
    update b(amount -= w_amount);

    val last_withdraw = eth_withdraw @? {} (@sort_desc .serial) limit 1;
    var next_serial = 0;
    if (empty(last_withdraw)) {
        next_serial += 1;
    } else {
        next_serial = last_withdraw + 1;
    }

    val w = create eth_withdraw(
        serial = next_serial,
        token,
        beneficiary,
        amount = w_amount
    );

    val eth_event_data = eth_event_data(
        serial = w.serial,
        token = byte_array.from_hex("000000000000000000000000" + w.token.sub(2)),
        beneficiary = byte_array.from_hex("000000000000000000000000" + w.beneficiary.sub(2)),
        amount = w.amount
    );

    val state_data = state_data(
        state_n = w.serial,
        account = eth_event_data
    );

    op_context.emit_event("el2_event", eth_event_data.to_gtv());
    op_context.emit_event("el2_state", state_data.to_gtv());
}

query get_withdrawal(token: text, beneficiary: text) {
    return eth_withdraw @* { token, beneficiary } (@sort_desc .serial, .token, .beneficiary, .amount);
}

query eth_balance_of(token: text, beneficiary: text): integer {
    val b = eth_balance @? { token, beneficiary } (.amount);
    if (empty(b)) {
        return 0;
    }
    return b;
}