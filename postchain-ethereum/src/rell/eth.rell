enum asset_type {
    erc20,
    erc721
}

entity eth_block {
    key eth_block_height: integer;
    key eth_block_hash: text;
}

entity eth_token {
    key token_address: text;
    token_type: asset_type;
    token_name: text;
    token_symbol: text;
}

entity eth_event {
    index eth_block;
    tnx_hash: text;
    log_index: integer;
    event_signature: text;
    contract_address: text;
    from_address: text;
    eth_token: eth_token;
    value: integer;
}

entity eth_balance {
    eth_token: eth_token;
    index beneficiary: text;
    mutable value: integer;
    token_uri: text;
}

entity eth_withdraw {
    key serial: integer;
    token: text;
    beneficiary: text;
    value: integer;
}

struct eth_event_data {
    serial: integer;
    token: byte_array;
    beneficiary: byte_array;
    value: integer;
}

struct state_data {
    state_n: integer;
    account: eth_event_data;
}

query get_last_eth_block() { return eth_block @? {} (@sort_desc .eth_block_height, .eth_block_hash) limit 1;}

operation __eth_block(eth_block_height: integer, eth_block_hash: text) {

    var eth_block = eth_block @? { eth_block_height, eth_block_hash };

    if (empty(eth_block)) {
        create eth_block(
            eth_block_height,
            eth_block_hash
        );
    }
}

operation __eth_event(eth_block_height: integer, eth_block_hash: text, tnx_hash: text, log_index: integer,
                        event_signature: text, contract_address: text,
                        token_type: asset_type, payload: gtv) {

    var eth_block = eth_block @? { eth_block_height, eth_block_hash };

    if (empty(eth_block)) {
        eth_block = create eth_block(
            eth_block_height,
            eth_block_hash
        );
    }

    val argList = list<gtv>.from_gtv(payload);

    var token_address = to_zero_padded_hex(byte_array.from_gtv(argList[1]));
    var eth_token = eth_token @? { token_address };
    if (empty(eth_token)) {
        var token_name = text.from_gtv(argList[3]);
        var token_symbol = text.from_gtv(argList[4]);

        eth_token = create eth_token(
            token_address,
            token_type,
            token_name,
            token_symbol
        );
    }
    var from_address = to_zero_padded_hex(byte_array.from_gtv(argList[0]));
    var token_value = integer.from_gtv(argList[2]);

    val eth_event = create eth_event(
        eth_block,
        tnx_hash,
        log_index,
        event_signature,
        contract_address,
        from_address,
        eth_token,
        value = token_value
    );

    if (token_type == asset_type.erc721) {
        var token_uri = text.from_gtv(argList[5]);
        create eth_balance(
            eth_token,
            beneficiary = from_address,
            value = token_value,
            token_uri
        );
        return;
    }

    val balance = eth_balance @? { .eth_token == eth_token, .beneficiary == from_address };

    if (empty(balance)) {
        create eth_balance(
            eth_token,
            beneficiary = from_address,
            value = token_value,
            token_uri = ""
        );
        return;
    }
    update balance (value += token_value);
}

operation withdraw(token_address: text, beneficiary: text, token_value: integer) {
    val t = eth_token @? { token_address };
    if (empty(t)) {
        return;
    }
    if (t.token_type == asset_type.erc20) {
        val b = eth_balance @ { .eth_token == t, beneficiary };
        require(b.value >= token_value, "Balance is too low");
        update b(value -= token_value);
    } else { // ERC721
        val b = eth_balance @ { .eth_token == t, .beneficiary == beneficiary, .value == token_value };
        require(b.value == token_value, "token id not found");
        delete b;
    }

    val last_withdraw = eth_withdraw @? {} (@sort_desc .serial) limit 1;
    var next_serial = 0;
    if (empty(last_withdraw)) {
        next_serial += 1;
    } else {
        next_serial = last_withdraw + 1;
    }

    val w = create eth_withdraw(
        serial = next_serial,
        token = token_address,
        beneficiary,
        value = token_value
    );

    val eth_event_data = eth_event_data(
        serial = w.serial,
        token = byte_array.from_hex("000000000000000000000000" + w.token.sub(2)),
        beneficiary = byte_array.from_hex("000000000000000000000000" + w.beneficiary.sub(2)),
        value = w.value
    );

    val state_data = state_data(
        state_n = w.serial,
        account = eth_event_data
    );

    op_context.emit_event("el2_event", eth_event_data.to_gtv());
    op_context.emit_event("el2_state", state_data.to_gtv());
}

query get_withdrawal(token: text, beneficiary: text) {
    return eth_withdraw @* { token , beneficiary } (@sort_desc .serial, .token, .beneficiary, .value);
}

query eth_balance_of(token_address: text, beneficiary: text): integer {
    val t = eth_token @? { token_address };
    if (empty(t)) {
        return 0;
    }
    val b = eth_balance @? { .eth_token == t, beneficiary } (.value);
    if (empty(b)) {
        return 0;
    }
    return b;
}

function to_zero_padded_hex(array: byte_array) {
    return "0x" + array.to_hex();
}