enum asset_type {
    ERC20,
    ERC721
}

entity account_link {
    state_n: integer;
    eth_beneficiary: text;
    key state_n, eth_beneficiary;
}

entity eth_block {
    eth_block_height: integer;
    eth_block_hash: byte_array;
    key eth_block_height, eth_block_hash;
}

entity eth_erc20 {
    key address: text;
    name: text;
    symbol: text;
    decimals: integer;
}

entity eth_erc721 {
    key address: text, token_id: integer;
    name: text;
    symbol: text;
    uri: text;
}

entity eth_event {
    index eth_block;
    tnx_hash: byte_array;
    log_index: integer;
    event_signature: byte_array;
    contract_address: byte_array;
    event_payload: byte_array;
}

entity eth_erc20_balance {
    token: eth_erc20;
    beneficiary: text;
    mutable amount: integer;
    key token, beneficiary;
}

entity eth_erc721_balance {
    token: eth_erc721;
    beneficiary: text;
    key token, beneficiary;
}

entity eth_erc20_withdraw {
    key serial: integer;
    index token: eth_erc20;
    index beneficiary: text;
    amount: integer;
}

entity eth_erc721_withdraw {
    key serial: integer;
    index token: eth_erc721;
    index beneficiary: text;
}

object withdraw_stats {
    mutable withdraw_count: integer = 0;
}

struct event_data {
    tnx_hash: byte_array;
    log_index: integer;
    signature: byte_array;
    contract_address: byte_array;
    asset_type: asset_type;
    payload: gtv;
}

struct state_data {
    state_n: integer;
    account: list<gtv>;
}

query get_last_eth_block() { return eth_block @? {} (@sort_desc .eth_block_height, .eth_block_hash) limit 1;}

operation __eth_block(eth_block_height: integer, eth_block_hash: byte_array, events: list<event_data>) {
    val eth_block = create eth_block(
        eth_block_height,
        eth_block_hash
    );

    for (event in events) {
        val eth_event = create eth_event(
            eth_block,
            tnx_hash = event.tnx_hash,
            log_index = event.log_index,
            event_signature = event.signature,
            contract_address = event.contract_address,
            event_payload = event.payload.to_bytes()
        );

        val event_args = list<gtv>.from_gtv(event.payload);
        val beneficiary = to_zero_padded_hex(byte_array.from_gtv(event_args[0]));
        when (event.asset_type) {
            ERC20 -> {
                val token_address = to_zero_padded_hex(byte_array.from_gtv(event_args[1]));
                val amount = integer.from_gtv(event_args[2]);
                val name = text.from_gtv(event_args[3]);
                val symbol = text.from_gtv(event_args[4]);
                val decimals = integer.from_gtv(event_args[5]);
                deposit_ERC20(beneficiary, token_address, amount, name, symbol, decimals);
            }
            ERC721 -> {
                val token_address = to_zero_padded_hex(byte_array.from_gtv(event_args[1]));
                val token_id = integer.from_gtv(event_args[2]);
                val name = text.from_gtv(event_args[3]);
                val symbol = text.from_gtv(event_args[4]);
                val uri = text.from_gtv(event_args[5]);
                deposit_ERC721(beneficiary, token_address, token_id, name, symbol, uri);
            }
        }
        val state_n = get_or_create_account_link(beneficiary);
        val state = build_account_state(beneficiary);
        val state_data = state_data(
            state_n,
            account = state
        );
        op_context.emit_event("el2_state", state_data.to_gtv());
    }
}

operation withdraw_ERC20(token_address: text, beneficiary: text, amount: integer) {
    require(amount > 0, "Must withdraw an amount larger than 0");
    val token = eth_erc20 @? { .address == token_address };
    if (empty(token)) {
        return;
    }

    val balance = eth_erc20_balance @? { token, beneficiary };
    require_not_empty(balance, "No balance for this token");
    require(balance.amount >= amount, "Balance is too low");
    update balance(.amount -= amount);

    update withdraw_stats(withdraw_count += 1);
    val next_serial = withdraw_stats.withdraw_count;

    create eth_erc20_withdraw(
        serial = next_serial,
        token,
        beneficiary,
        amount
    );

    val withdraw_info = list<gtv>();
    withdraw_info.add(next_serial.to_gtv());
    withdraw_info.add(byte_array.from_hex("000000000000000000000000" + token_address.sub(2)).to_gtv());
    withdraw_info.add(byte_array.from_hex("000000000000000000000000" + beneficiary.sub(2)).to_gtv());
    withdraw_info.add(amount.to_gtv());
    emit_withdraw(beneficiary, withdraw_info);
}

operation withdraw_ERC721(token_address: text, beneficiary: text, token_id: integer) {
    val token = eth_erc721 @? { .address == token_address, token_id };
    if (empty(token)) {
        return;
    }

    val balance = eth_erc721_balance @? { token, beneficiary };
    require_not_empty(balance, "No balance for this token");
    delete balance;

    update withdraw_stats(withdraw_count += 1);
    val next_serial = withdraw_stats.withdraw_count;

    create eth_erc721_withdraw(
        serial = next_serial,
        token,
        beneficiary
    );

    val withdraw_info = list<gtv>();
    withdraw_info.add(next_serial.to_gtv());
    withdraw_info.add(byte_array.from_hex("000000000000000000000000" + token_address.sub(2)).to_gtv());
    withdraw_info.add(byte_array.from_hex("000000000000000000000000" + beneficiary.sub(2)).to_gtv());
    withdraw_info.add(token_id.to_gtv());
    emit_withdraw(beneficiary, withdraw_info);
}

query get_erc20_withdrawal(token_address: text, beneficiary: text) {
    val token = eth_erc20 @? { .address == token_address };
    if (empty(token)) {
        return null;
    }

    return eth_erc20_withdraw @* { token , beneficiary } (@sort_desc .serial, token = .token.address, .beneficiary, .amount);
}

query get_erc721_withdrawal(token_address: text, token_id: integer, beneficiary: text) {
    val token = eth_erc721 @? { .address == token_address, token_id };
    if (empty(token)) {
        return null;
    }

    return eth_erc721_withdraw @* { token, beneficiary } (@sort_desc .serial, token = .token.address, .beneficiary);
}

query eth_balance_of_erc20(token_address: text, beneficiary: text): integer {
    val t = eth_erc20 @? { .address == token_address };
    if (empty(t)) {
        return 0;
    }
    val b = eth_erc20_balance @? { .token == t, beneficiary } (.amount);
    if (empty(b)) {
        return 0;
    }
    return b;
}

query eth_has_erc721(token_address: text, token_id: integer, beneficiary: text): boolean {
    val t = eth_erc721 @? { .address == token_address, token_id };
    if (empty(t)) {
        return false;
    }
    val b = eth_erc721_balance @? { .token == t, beneficiary };
    return not empty(b);
}

function get_or_create_account_link(beneficiary: text): integer {
    val account = account_link @? { beneficiary };
    if (empty(account)) {
        val last_state_n = account_link @? {} (@sort_desc .state_n) limit 1;
        var next_state_n = 0;
        if (empty(last_state_n)) {
            next_state_n = 1;
        } else {
            next_state_n = last_state_n + 1;
        }
        create account_link(
            state_n = next_state_n,
            beneficiary
        );
        return next_state_n;
    }
    return account.state_n;
}

function build_account_state(beneficiary: text) {
	val state = list<gtv>();
	state.add(byte_array.from_hex("000000000000000000000000" + beneficiary.sub(2)).to_gtv());
	// In order of asset type
	// 0: ERC20
	val erc20_balances = eth_erc20_balance @* { beneficiary };
	val erc20_byte_offset = erc20_balances.size() * 2 * 32; // 2 values per entry
	state.add(erc20_byte_offset.to_gtv());
	for (balance in erc20_balances) {
		state.add(byte_array.from_hex("000000000000000000000000" + balance.token.address.sub(2)).to_gtv());
		state.add(balance.amount.to_gtv());
	}
	// 1: ERC721
	val erc721_balances = eth_erc721_balance @* { beneficiary };
	val erc721_byte_offset = erc721_balances.size() * 2 * 32; // 2 values per entry
	state.add(erc721_byte_offset.to_gtv());
	for (balance in erc721_balances) {
		state.add(byte_array.from_hex("000000000000000000000000" + balance.token.address.sub(2)).to_gtv());
		state.add(balance.token.token_id.to_gtv());
	}
	// Add new asset types here
	// ------------------------ //
	return state;
}

function deposit_ERC20(beneficiary: text, token_address: text, amount: integer, name: text, symbol: text, decimals: integer) {
    var token = eth_erc20 @? { .address == token_address };
    if (empty(token)) {
          token = create eth_erc20(
              address = token_address,
              name,
              symbol,
              decimals
          );
      }

    val balance = eth_erc20_balance @? { token, beneficiary };
    if (empty(balance)) {
        create eth_erc20_balance(
            token,
            beneficiary,
            amount
        );
    } else {
        update balance (.amount += amount);
    }
}

function deposit_ERC721(beneficiary: text, token_address: text, token_id: integer, name: text, symbol: text, uri: text) {
    var token = eth_erc721 @? { .address == token_address, token_id };
    if (empty(token)) {
          token = create eth_erc721(
              address = token_address,
              token_id,
              name,
              symbol,
              uri
          );
    }

    create eth_erc721_balance(
        token,
        beneficiary
    );
}

function emit_withdraw(beneficiary: text, eth_event_data: list<gtv>) {
    val state_n = get_or_create_account_link(beneficiary);
    val state = build_account_state(beneficiary);
    val state_data = state_data(
        state_n,
        account = state
    );

    op_context.emit_event("el2_state", state_data.to_gtv());
    op_context.emit_event("el2_event", eth_event_data.to_gtv());
}

function to_zero_padded_hex(array: byte_array) {
    return "0x" + array.to_hex();
}
