// Copyright (c) 2020 ChromaWay AB. See README for license information.

package net.postchain.base.data

import net.postchain.base.data.SAPQueryExecutor.executeByteArrayQuery
import net.postchain.core.EContext
import net.postchain.core.TxDetail
import java.sql.Connection

class SAPHanaSQLDatabaseAccess : SQLDatabaseAccess() {

    override fun isSavepointSupported(): Boolean = false

    override fun createSchema(connection: Connection, schema: String) {
        val sql = "CREATE SCHEMA \"$schema\""
        queryRunner.update(connection, sql)
    }

    override fun setCurrentSchema(connection: Connection, schema: String) {
        val sql = "SET SCHEMA \"$schema\""
        queryRunner.update(connection, sql)
    }

    override fun dropSchemaCascade(connection: Connection, schema: String) {
        val sql = "DROP SCHEMA \"$schema\" CASCADE"
        queryRunner.update(connection, sql)
    }

    override fun insertSnapshot(ctx: EContext, rootHash: ByteArray, height: Long): Long {
        TODO("Not yet implemented")
    }

    override fun cmdCreateTableBlocks(ctx: EContext): String {
        return "CREATE TABLE ${tableBlocks(ctx)}" +
                " (block_iid BIGINT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY," +
                "  block_height BIGINT NOT NULL, " +
                "  block_rid VARBINARY(1000)," +
                "  chain_iid BIGINT NOT NULL," +
                "  block_header_data BLOB," +
                "  block_witness BLOB," +
                "  timestamp BIGINT," +
                "  UNIQUE (chain_iid, block_rid)," +
                "  UNIQUE (chain_iid, block_height))"
    }

    override fun cmdCreateTableBlockchains(): String {
        return "CREATE TABLE ${tableBlockchains()} " +
                " (chain_iid BIGINT, blockchain_rid VARBINARY(1000) NOT NULL)"
    }

    override fun cmdCreateTableTransactions(ctx: EContext): String {
        return "CREATE TABLE ${tableTransactions(ctx)} (" +
                "    tx_iid BIGINT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, " +
                "    chain_iid bigint NOT NULL," +
                "    tx_rid VARBINARY(1000) NOT NULL," +
                "    tx_data BLOB NOT NULL," +
                "    tx_hash VARBINARY(1000) NOT NULL," +
                "    block_iid BIGINT NOT NULL REFERENCES ${tableBlocks(ctx)}(block_iid)," +
                "    UNIQUE (chain_iid, tx_rid))"
    }

    override fun cmdCreateTableConfigurations(ctx: EContext): String {
        return "CREATE TABLE ${tableConfigurations(ctx)} (" +
                " chain_iid bigint NOT NULL" +
                ", height BIGINT NOT NULL" +
                ", configuration_data BLOB NOT NULL" +
                ", PRIMARY KEY (chain_iid, height)" +
                ")"
    }

    override fun cmdCreateTableSnapshots(ctx: EContext): String {
        TODO("Not yet implemented")
    }

    override fun cmdCreateTablePeerInfos(): String {
        return "CREATE TABLE ${tablePeerinfos()} (" +
                " $TABLE_PEERINFOS_FIELD_HOST VARCHAR(255) NOT NULL" +
                ", $TABLE_PEERINFOS_FIELD_PORT BIGINT NOT NULL" +
                ", $TABLE_PEERINFOS_FIELD_PUBKEY VARCHAR(255) NOT NULL" +
                ", $TABLE_PEERINFOS_FIELD_TIMESTAMP TIMESTAMP NOT NULL" +
                ")"
    }

    override fun cmdCreateTableMeta(): String {
        return "CREATE TABLE ${tableMeta()} (key VARCHAR(255) PRIMARY KEY, value VARCHAR(1000))"
    }

    override fun cmdCreateTableGtxModuleVersion(ctx: EContext): String {
        return "CREATE TABLE ${tableGtxModuleVersion(ctx)} (module_name VARCHAR(1000) PRIMARY KEY, version BIGINT NOT NULL)"
    }

    override fun cmdCreateDescribeTableFunction(ctx: EContext): String {
        TODO("Not yet implemented")
    }

    override fun cmdInsertBlocks(ctx: EContext): String {
        return "INSERT INTO ${tableBlocks(ctx)} (chain_iid, block_height) VALUES (?, ?) "
    }

    override fun cmdInsertSnapshots(ctx: EContext): String {
        TODO("Not yet implemented")
    }

    override fun cmdInsertTransactions(ctx: EContext): String {
        return "INSERT INTO ${tableTransactions(ctx)} (chain_iid, tx_rid, tx_data, tx_hash, block_iid) " +
                "VALUES (?, ?, ?, ?, ?) "
    }

    override fun cmdInsertConfiguration(ctx: EContext): String {
        return "UPSERT ${tableConfigurations(ctx)} (chain_iid, height, configuration_data) VALUES (?, ?, ?) "
    }

    override fun getBlockHeader(ctx: EContext, blockRID: ByteArray): ByteArray {
        val sql = "SELECT block_header_data FROM ${tableBlocks(ctx)} where chain_iid = ? and block_rid = ?"

        return executeByteArrayQuery(ctx, sql) {
            it.setLong(1, ctx.chainID)
            it.setBytes(2, blockRID)
        } ?: byteArrayOf()
    }

    override fun getBlockTransactions(ctx: EContext, blockRID: ByteArray, hashesOnly: Boolean): List<TxDetail> {
        val sql = """
            SELECT tx_rid, tx_hash${if (hashesOnly) "" else ", tx_data"}
            FROM ${tableTransactions(ctx)} t
            JOIN ${tableBlocks(ctx)} b ON t.block_iid=b.block_iid
            WHERE b.chain_iid = ? AND b.block_rid = ?
            ORDER BY tx_iid"""

        val statement = ctx.conn.prepareStatement(sql)
                .apply {
                    setLong(1, ctx.chainID)
                    setBytes(2, blockRID)
                }

        val resultSet = statement.executeQuery()

        val txs = mutableListOf<TxDetail>()
        while (resultSet.next()) {
            txs.add(TxDetail(
                    resultSet.getBlob(1).binaryStream.readBytes(),
                    resultSet.getBlob(2).binaryStream.readBytes(),
                    if (hashesOnly) null else resultSet.getBlob(3).binaryStream.readBytes()
            ))
        }

        return txs
    }

    override fun getWitnessData(ctx: EContext, blockRID: ByteArray): ByteArray {
        val sql = "SELECT block_witness FROM ${tableBlocks(ctx)} WHERE chain_iid = ? AND block_rid = ?"

        return executeByteArrayQuery(ctx, sql) {
            it.setLong(1, ctx.chainID)
            it.setBytes(2, blockRID)
        } ?: byteArrayOf()
    }

    override fun getTxBytes(ctx: EContext, txRID: ByteArray): ByteArray? {
        val sql = "SELECT tx_data FROM ${tableTransactions(ctx)} WHERE chain_iid=? AND tx_rid=?"

        return executeByteArrayQuery(ctx, sql) {
            it.setLong(1, ctx.chainID)
            it.setBytes(2, txRID)
        } ?: byteArrayOf()
    }

    override fun getConfigurationData(ctx: EContext, height: Long): ByteArray? {
        val sql = "SELECT configuration_data FROM ${tableConfigurations(ctx)} WHERE chain_iid = ? AND height = ?"

        return executeByteArrayQuery(ctx, sql) {
            it.setLong(1, ctx.chainID)
            it.setLong(2, height)
        }
    }
}