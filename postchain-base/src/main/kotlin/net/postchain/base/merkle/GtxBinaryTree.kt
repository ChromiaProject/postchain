package net.postchain.base.merkle

import net.postchain.base.merkle.MerkleBasics.HASH_PREFIX_NODE_GTX_ARRAY
import net.postchain.base.merkle.MerkleBasics.HASH_PREFIX_NODE_GTX_DICT
import net.postchain.gtx.*
import java.util.SortedSet

/**
 * In this file we handle the most common case, where the binary tree holds only [GTXValue] s.
 *
 * When we calculate the merkle root hash, we need get different hashes if 2 trees have same leaf elements,
 * but different internal structure. Therefore we use special [GtxArrayHeadNode] and [GtxDictHeadNode] to
 * signal this difference.
 */

/**
 * Represents the top of a sub tree generated by a [ArrayGTXValue]
 */
class GtxArrayHeadNode(left: BinaryTreeElement, right: BinaryTreeElement, isProofLeaf: Boolean, content: GTXValue, val size: Int):
        SubTreeRootNode<GTXValue>(left, right, isProofLeaf, content) {

    override fun getPrefixByte(): Byte = HASH_PREFIX_NODE_GTX_ARRAY
}

/**
 * Represents the top a sub tree generated by a [DictGTXValue]
 */
class GtxDictHeadNode(left: BinaryTreeElement, right: BinaryTreeElement, isProofLeaf: Boolean, content: GTXValue, val size: Int):
        SubTreeRootNode<GTXValue>(left, right, isProofLeaf, content){

    override fun getPrefixByte(): Byte = HASH_PREFIX_NODE_GTX_DICT
}

/**
 * Represents a [BinaryTree] that only holds GTX values
 */
class GtxBinaryTree(root: BinaryTreeElement) : BinaryTree<GTXValue>(root) { }
