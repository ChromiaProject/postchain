package net.postchain.base.merkle

import net.postchain.gtx.*
import java.util.SortedSet

/**
 * In this file we handle the most common case, where the binary tree holds only [GTXValue] s.
 *
 * When we calculate the merkle root hash, we need get different hashes if 2 trees have same leaf elements,
 * but different internal structure. Therefore we use special [GtxArrayHeadNode] and [GtxDictHeadNode] to
 * signal this difference.
 */

/**
 * Represents the top of a sub tree generated by a [ArrayGTXValue]
 */
class GtxArrayHeadNode(left: FbtElement, right: FbtElement): Node(left, right) {

    companion object GtxArrayNodeCompanion{
        const val prefixByte: Byte = 7
    }

    override fun getPrefixByte(): Byte {
        return prefixByte
    }
}

/**
 * Represents the top a sub tree generated by a [DictGTXValue]
 */
class GtxDictHeadNode(left: FbtElement, right: FbtElement): Node(left, right) {

    companion object GtxDictNodeCompanion{
        const val prefixByte: Byte = 8
    }

    override fun getPrefixByte(): Byte {
        return prefixByte
    }
}

/**
 * Represents a [ContentLeafFullBinaryTree] that only holds GTX values
 */
class GtxFullBinaryTree(root: FbtElement) : ContentLeafFullBinaryTree<GTXValue>(root) {


}

class GtxTreeElementFinder<T> {

    /**
     * Use this to find [GTXValue] s in the tree
     *
     * @param toFind this can be a string or int, depending on the type param T
     * @param node the root of the tree we are looking in
     * @return A list of [GTXValue] , usually just containing one element, but can contain many, if say the same
     *          string "foo" appear in many places in the tree.
     */
    fun findGtxValueFromPrimitiveType(toFind: T, node: FbtElement): List<GTXValue> {
        val retArr = arrayListOf<GTXValue>()
        when (node) {
            is Node ->  {
                val leftList = findGtxValueFromPrimitiveType(toFind, node.left)
                val rightList = findGtxValueFromPrimitiveType(toFind, node.right)
                retArr.addAll(leftList)
                retArr.addAll(rightList)
            }
            is Leaf<*> -> {
                val gtxVal = node.content
                when (gtxVal) {
                    is StringGTXValue -> {
                        if (toFind is String && toFind == gtxVal.string) {
                            println("Found the string $toFind")
                            retArr.add(gtxVal)
                        }
                    }
                    is IntegerGTXValue -> {
                        //println("Looking for: $toFind a num: ${gtxVal.integer} ")
                        if (toFind is Int && toFind.toString() == gtxVal.integer.toString()) { // TODO: This conversion to string is ugly but for some reason comparison beween ints did not work!!??
                            println("Found the int $toFind")
                            retArr.add(gtxVal)
                        }
                    }
                }
            }
        }
        return retArr
    }
}


class GtxFullBinaryTreeFactory : CompleteBinaryTreeFactory<GTXValue>() {


    /**
     * Generic builder.
     * @param gtxValue will take any damn thing
     */
    fun buildFromGtx(gtxValue: GTXValue): GtxFullBinaryTree {
        val result = handleLeaf(gtxValue)
        return GtxFullBinaryTree(result)
    }

    /**
     * Probably only for testing
     */
    fun buildFromArrayList(originalList: List<GTXValue>): GtxFullBinaryTree {
        val result = buildSubTree(originalList)
        return GtxFullBinaryTree(result)
    }


    // ------------ Internal ----------


    /**
     * There are 2 edge cases here:
     * - When the array is empty. -> We return a top node with two empty leafs
     * - When there is only one element. -> We set the right element as empty
     */
    private fun buildFromArrayGTXValue(arrayGTXValue: ArrayGTXValue): FbtElement {
        val leafList: List<GTXValue> = arrayGTXValue.array.map {it}
        if (leafList.isEmpty()) {
            return GtxArrayHeadNode(EmptyLeaf, EmptyLeaf)
        }

        val orgRoot = buildSubTree(leafList)
        return when (orgRoot) {
            is Node -> {
                GtxArrayHeadNode(orgRoot.left, orgRoot.right)
            }
            is Leaf<*> -> {
                if (leafList.size > 1) {
                    throw IllegalStateException("How come we got a leaf returned when we had ${leafList.size} elements is the array?")
                } else {
                    // Create a dummy to the right
                    GtxArrayHeadNode(orgRoot, EmptyLeaf)
                }
            }
            else -> throw IllegalStateException("Should not find element of this type here: $orgRoot")
        }
    }

    /**
     * The strategy for transforming [DictGTXValue] is pretty simple, just flatten it into an array.
     * If you want to prove a ( [String] to [GTXValue] ) pair, you then have to prove both elements.
     *
     * There is an edge cases here:
     * - When the dict is empty. -> We return a top node with two empty leafs
     */
    private fun buildFromDictGTXValue(dictGTXValue: DictGTXValue): GtxDictHeadNode {
        val keys: SortedSet<String> = dictGTXValue.dict.keys.toSortedSet() // Needs to be sorted, or else the order is undefined

        if (keys.isEmpty()) {
            return GtxDictHeadNode(EmptyLeaf, EmptyLeaf)
        }

        val flattenedDictList = arrayListOf<GTXValue>()

        for (key in keys) {
            //println("key extracted: $key")
            val keyGtxString: GTXValue = StringGTXValue(key)
            flattenedDictList.add(keyGtxString)

            val content: GTXValue = dictGTXValue.get(key)!!
            flattenedDictList.add(content)
        }

        val orgRoot = buildSubTree(flattenedDictList)
        return when (orgRoot) {
            is Node -> GtxDictHeadNode(orgRoot.left, orgRoot.right)
            else -> throw IllegalStateException("Should not find element of this type here: $orgRoot")
        }
    }


    /**
     * Handles different types of [GTXValue] values
     */
    override fun handleLeaf(leaf: GTXValue): FbtElement {
        return when (leaf) {
            is ArrayGTXValue -> buildFromArrayGTXValue(leaf)
            is DictGTXValue -> buildFromDictGTXValue(leaf)
            else -> Leaf(leaf)
        }
    }
}