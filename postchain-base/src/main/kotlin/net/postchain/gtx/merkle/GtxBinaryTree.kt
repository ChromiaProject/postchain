package net.postchain.gtx.merkle

import net.postchain.base.merkle.BinaryTree
import net.postchain.base.merkle.BinaryTreeElement
import net.postchain.gtx.merkle.GtxMerkleBasics.HASH_PREFIX_NODE_GTX_ARRAY
import net.postchain.gtx.merkle.GtxMerkleBasics.HASH_PREFIX_NODE_GTX_DICT
import net.postchain.base.merkle.SubTreeRootNode
import net.postchain.gtx.*

/**
 * In this file we handle the most common case, where the binary tree holds only [GTXValue] s.
 *
 * When we calculate the merkle root hash, we need get different hashes if 2 trees have same leaf elements,
 * but different internal structure. Therefore we use special [GtxArrayHeadNode] and [GtxDictHeadNode] to
 * signal this difference.
 */

/**
 * Represents the top of a sub tree generated by a [ArrayGTXValue]
 *
 * @param size is how many element we have in the original array.
 */
class GtxArrayHeadNode(left: BinaryTreeElement, right: BinaryTreeElement, isProofLeaf: Boolean, content: GTXValue, val size: Int):
        SubTreeRootNode<GTXValue>(left, right, isProofLeaf, content) {

    override fun getPrefixByte(): Byte = HASH_PREFIX_NODE_GTX_ARRAY
}

/**
 * Represents the top a sub tree generated by a [DictGTXValue]
 *
 * @param size is how many key-pairs we have in the original dict.
 */
class GtxDictHeadNode(left: BinaryTreeElement, right: BinaryTreeElement, isProofLeaf: Boolean, content: GTXValue, val size: Int):
        SubTreeRootNode<GTXValue>(left, right, isProofLeaf, content){

    override fun getPrefixByte(): Byte = HASH_PREFIX_NODE_GTX_DICT
}

/**
 * Represents a [BinaryTree] that only holds GTX values.
 */
class GtxBinaryTree(root: BinaryTreeElement) : BinaryTree<GTXValue>(root) { }
